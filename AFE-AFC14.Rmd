---
title: "Identier les facteurs latents en SHS avec R"
subtitle: "Exemples d'application sur des données en Géographie et en Psychologie en utilisant le couple analyse factorielle exploratoire (AFE) / analyse factorielle confirmatoire (CFA)"
date: "`r Sys.Date()`"
author: 
 - name: Grégoire Le Campion
   affiliation: Passages, CNRS
 - name: Solenne Roux
   affiliation: LabPsy, Université de Bordeaux
image: "figures/featured.png"   
logo: "figures/rzine.png"  
output:
  rzine::readrzine:
    highlight: kate
    number_sections: true
csl: Rzine_citation.csl
bibliography: biblio.bib
nocite: |
  @*
link-citations: true
# github: "author/repository"
# gitlab: "gitlab.huma-num.fr/author/repository"
# doi: "xx.xxx/xxxx.xxxxxxx"
# licence: "by-sa"

# Only Creative Commons Licence 
# 5 possible choices : "by-nd", "by", "by-nc-sa", "by-nc","by-sa"
---

<style>
body {
text-align: justify}
</style>


```{r setup, include=FALSE}

## Global options
knitr::opts_chunk$set(echo=TRUE,
        	            cache=FALSE,
                      prompt=FALSE,
                      comment=NA,
                      message=FALSE,
                      warning=FALSE,
                      class.source="bg-info",
                      class.output="bg-warning")


```


> Cette fiche présente deux méthodes d'analyse factorielle et leurs applications sous R. Ces méthodes cousines de l'analyse en  composante principale, s'en distinguent notamment car elles permettent de mettre en évidence des facteurs latents plutôt que des composantes principales. Cette approche par les facteurs latents est surtout utilisée en Psychologie. Moins répandue dans les autres disciplines des sciences humaines et sociales, elle pourrait néanmoins s'avérer particulièrement utile pour répondre à des hypothèses ou besoins particuliers dans toutes les disciplines des SHS.

> **Pré-requis** : Connaissances de base en traitement et analyse de données. Être familier des risques induits par les outliers, la multicolinéarité, etc. dans la modélisation statistique.

# Introduction {-}


# L'analyse factorielle

*Comment rendre compte, de manière simple, de la complexité des différents types de relations qui existent entre plusieurs variables d'une base de données ?*

C'est à cette question que permet, entre autre, de répondre l'analyse multivariée, et par extension les méthodes d'analyses factorielles qui appartiennent à ce champs de méthodes.


## L'Objectif de l'analyse factorielle ?

L'objectif général de l'analyse factorielle est de réduire un nombre important d'informations (c'est-à-dire les valeurs contenues dans différentes variables) à quelques grandes dimensions. Il s'agit de synthétiser l'information.
Par exemple, imaginons des chercheurs souhaitant étudier le comportement de préservation de l'environnement des français. Pour cela, ils récoltent différentes données concernant le statut socioprofessionnel des participants, leur état de santé, leur zone géographique d'habitation, leur implication dans des associations, etc. Ils recueillent donc beaucoup de données dans chacun des différents thèmes susceptibles d'expliquer leurs hypothèses. Afin de synthétiser l'information alors recueillie, et éventuellement par la suite de pouvoir dégager des profils de comportement ou des liens de causalités, ils feront appel à l'une des méthodes de factorisation existante.

Comme dans toute analyse statistique, on va chercher à expliquer la plus forte proportion de la variance (de la covariance dans le cas de l'analyse factorielle) par un nombre aussi restreint que possible de variables (appelées dans l'analyse factorielle composantes ou facteurs).


## Les différents types d'analyses factorielles

L'analyse factorielle est, elle aussi, un regroupement de différentes méthodes dont les plus connues et les plus utilisées en SHS sont, pour les données quantitatives : l'analyse en composante principale (ACP) et l'analyse factorielle exploratoire (AFE) ; et pour les données qualitatives : l'analyse factorielle des correspondances (AFC) et l'analyse des correspondances multiples (ACM).

Ici nous vous parlerons des méthodes de l'analyse factorielle exploratoire (AFE ou EFA en anglais) et de l'analyse factorielle confirmatoire (CFA en anglais) qui sont des méthodes très employées en psychologie notamment.

Ces différentes méthodes, si elles ont toutes l'objectif commun que nous avons exprimé précédemment, ont aussi des différences importantes.

Pour mieux comprendre, un rapide retour historique sur ces méthodes est utile.

## Petite histoire des analyses factorielles

Les premiers à théoriser les méthodes d'analyses factorielles sont le mathématicien britannique Karl Pearson (1901) et le psychologue anglais Charles Spearman (1904).

Pearson développera sa réflexion sur les analyses en compostantes principales (ACP) (Pearson F.R.S., K., 1901). Alors que Spearman se concentrera sur l'analyse factorielle, afin de rendre compte de la variance commune partagée par les items d'un même outil psychométrique (Spearman, C., 1904).
Ces pionniers des analyses factorielles travaillaient déjà sur les corrélations, et ce sont ces mêmes personnes qui ont donné leurs noms aux coefficients de corrélation  de Pearson et de Spearman.

Mais c'est notamment avec les travaux du mathématicien français Jean-Paul Benzecri (Benzecri J.-P., 1973), dans les années 70, que ces méthodes vont connaître leur essor en France (Pages, J-P., et al., 1979). En particulier grâce à l'apport des représentations graphiques qui permettent de venir synthétiser et illustrer les résultats.
C'est Benzecri qui va développer les méthodes sortant du modèle gaussien en prenant en compte les variables catégorielles, telles que les analyses factorielles des correspondances (AFC) et les analyses factorielles des correspondances multiples (ACM)(Pages, J-P., et al., 1979).


Si les méthodes popularisées par Benzecri ont su rester à la postérité et servir dans toutes les SHS, notamment grâce à la mise en oeuvre des méthodes pour travailler sur des données qualitatives, il peut être utile de se rappeler qu'il en existe d'autres qui les ont précédées. C'est par exemple le cas de l'analyse factorielle exploratoire (AFE). Cette méthode, si elle est très utilisée en psychologie - discipline de Spearman, reste effectivement beaucoup plus rare dans les autres sciences humaines et sociales.

# L' AFE pour quoi faire

L'AFE vise à explorer la structure sous-jacente d'une base de donnée en identifiant des facteurs latents qui vont expliquer les relations entre les variables de notre base de données.

Qu'est ce qu'un facteur latent ? C'est une variable qui est sous-jacente, car non observée ou mesurée directement. Ce facteur sous-jacent est postulé pour expliquer les covariances (ou corrélations) entre l'ensemble des variables observées et mesurées (celles de notre base de données). Les variables observées, sont mesurées directement, tandis que les facteurs latents ne le sont pas.

Cette notion de facteur latent est au coeur de l'analyse factorielle exploratoire. En effet l'idée centrale de cette méthode est que nos variables mesurées sont influencées par ces facteurs latents, et que ces facteurs vont expliquer la structure des relations des variables entre elles. Chaque facteur latent est associé à un groupe de variables qui partagent une variance commune. En d'autres termes, le facteur latent "capture" l'information partagée par un ensemble de variables.
Supposons que nous avons une base de données constituée de variables mesurant un ensemble de critères observables. Par exemple, lors d'un match de rugby nous avons collecté le nombre de mètres parcourus, de points marqués, du nombre de passes, de plaquages... On pourrait postuler l'existence de facteurs latents qu'on pourrait appeler "performance" et "vision de jeu". Ces deux facteurs latents ne peuvent pas être mesurés directement, mais peuvent être postulés pour tenter d'expliquer la variation commune de nos variables observées/mesurées.
Notre objectif lorsque l'on réalise une AFE sera d'identifier le nombre et la nature de ces facteurs latents et de comprendre comment ils sont associés et reliés aux variables mesurées.

Cette méthode est donc particulièrement intéressante et appropriée pour comprendre les dimensions sous-jacentes des données et les relations entre les variables. Elle va permettre de faire émerger un pattern de relations entre ces variables. C'est en cela qu'elle peut s'avérer particulièrement utile. Elle permet de rendre compte de phénomènes (les facteurs latents) que l'on suppose (par exemple la vision de jeu), mais qui sont trop complexes pour être mesurés directement.

Ainsi, si on cherche à explorer et à identifier des dimensions explicatives sous-jacentes, qui influencent nos variables, comme c'est souvent le cas en SHS, l'AFE s'avérera être un bon choix.
Autre avantage important de l'analyse factorielle exploratoire, c'est qu'elle permet ensuite de réaliser une analyse factorielle confirmatoire, sur laquelle nous reviendrons plus tard dans cet article.

L'ACP est très utilisée dans l'ensemble des disciplines des SHS, quelque soit l'hypothèse testée. Ceci correspond davantage à des habitudes d'utilisation ou de certaines pratiques de la donnée, qu'à une réelle réflexion sur les méthodes de factorisation. Or, l'analyse en Composante Principale et l'Analyse Factorielle Exploratoire ne répondent pas aux mêmes besoins et aux mêmes hypothèses. L'AFE répond en réalité à des besoins et des manières de penser très courantes dans toutes les SHS, et dans certains cas devrait être privilégiée à l'ACP.

Par exemple, en géographie, l'AFE peut être utilisée pour comprendre les dimensions sous-jacentes des comportements humains et des phénomènes socio-spatiaux. Elle offre un moyen exploratoire et puissant d'analyser la structure des données géographiques, d'identifier des tendances spatiales, et d'améliorer la compréhension des relations entre les variables. Voici quelques exemples concrets où l'AFE peut s'avérer utile :

- **La réduction de la dimensionnalité**. L'AFE reste une méthode d 'analyse factorielle, son objectif est donc une "simplification" ou synthèse de la donnée. Ainsi, l'AFE permet de réduire la dimensionnalité des données en identifiant des facteurs latents explicatifs de la variance partagée entre les variables. Cela facilite la simplification de l'analyse et la synthèse des informations.

- **L'identification de structures spatiales**. L'AFE permet d'identifier des structures spatiales latentes ou des modèles sous-jacents dans les données géographiques. Par exemple, elle peut révéler des tendances ou des regroupements dans les caractéristiques géographiques qui ne sont pas évidents à partir d'une simple observation des données brutes.

- **L'Analyse des relations spatiales**. L'AFE peut être utilisée pour explorer les relations entre différentes variables géographiques. Par exemple, elle peut aider à identifier des facteurs qui expliquent la covariance spatiale entre des indicateurs socio-économiques, environnementaux ou démographiques. Elle est ainsi pertinente pour identifier des facteurs qui influencent la distribution spatiale des phénomènes.

- **La modélisation du spatial**. L'AFE peut être utilisée comme une étape préliminaire pour la modélisation spatiale. Elle met en lumière les variables les plus influentes dans un modèle et simplifie la modélisation en réduisant le nombre de variables. 

- **La validation des mesures**. Il est parfois nécesaire de mesurer des concepts complexes comme la qualité de vie, le développement régional, etc. L'AFE peut être employée afin de valider les mesures en identifiant les facteurs latents qui contribuent à ces concepts et en évaluant la cohérence des mesures.

## ACP et AFE et quelles différences ?

En réalité, les différences entre ces deux méthodes sont importantes, bien que pas si simple à appréhender intuitivement. Ces deux méthodes vont différer tant dans leur objectif que dans leur approche. Ainsi, voici trois points principaux où ces méthodes divergent et qu'il est nécessaire de prendre en compte pour faire un choix éclairé entre **analyse en composantes principale** et **analyse factorielle exploratoire** : l'objectif principal, la nature des variables et l'interprétation des résultats.


1- L'objectif principal :

ACP et AFE ont comme objectif commun la réduction de l'information, mais elles ne vont pas du tout opérer de la même manière.

  - l'ACP : l'objectif est de réduire la dimensionnalité des données en utilisant les composantes principales. L'ACP va transformer les variables observées en un ensemble de variables non corrélées, que l'on appelle composantes principales. Dans l'ACP nous n'allons pas rechercher des facteurs latents.
  La composante principale est une combinaison linéaire des variables originales qui capture le plus possible de variance présente dans les données. Ces composantes principales sont classées par ordre décroissant de l'importance de la variance qu'elles capturent. Tout l'enjeu de l'ACP est de définir des composantes principales qui permettent de réduire la dimensionnalité des données tout en conservant l'information essentielle contenue dans les variables d'origine. Les composantes principales étant des variables non corrélées entre elles, cela simplifie l'interprétation des relations entre les observations. Pour résumer, l'objectif principal de l'ACP est de synthétiser nos données en composantes principales en tentant de conserver le maximum de variance des variables de notre base de données.
  - L'AFE : vise à explorer la structure sous-jacente des données en identifiant des facteurs latents qui expliquent les relations entre les variables observées. L'objectif est de réduire la dimensionnalité des données en se centrant sur la variance partagée entre les variables et non sur l'ensemble des données. Dans le cadre de l'AFE, une partie de la variance des données ne sera pas retenue dans le modèle. L'objectif n'étant pas de conserver le maximum de variance de notre jeu de données, mais bien de se centrer sur la variance partagée entre les différentes variables. 
  
2- La nature des variables :

  - L'ACP : Les variables de notre base de données sont plutôt considérées comme des mesures directes. On cherche à réduire la dimensionnalité sans nécessairement interpréter les composantes principales en tant que telles.
  - L'AFE : Les variables sont considérées comme des indicateurs de facteurs latents. On souhaite comprendre la structure sous-jacente de notre base de données.

3- Interprétabilité :

- L'ACP : Les composantes principales sont des combinaisons linéaires des variables originales et peuvent être peu interprétables du point de vue conceptuel.
On va considérer le poids ou la contribution d'une variable pour chaque composante principale, ce qui va permettre de mesurer l'importance relative des variables dans la variance totale de nos données.
- L'AFE : Les facteurs latents identifiés sont souvent interprétables comme des concepts sous-jacents aux données, mais qu'il est nécessaire d'identifier et de théoriser.
Pour l'interprétation, nous allons étudier les charges factorielles associées à chaque facteur latent. Il s'agit tout simplement des corrélations de chaque variable avec chaque facteur latent. Ces corrélations nous permettent d'étudier la relation entre les variables et les facteurs latents, et donc de donner du sens à ces facteurs alors identifiés.
L'analyse factorielle exploratoire repose sur la comparaison entre la matrice de corrélation initiale (sans la grille de lecture obtenue suite à l'identification des facteurs latents) et la matrice de corrélation obtenue suite à l'identification des facteurs. Si la différence entre ces deux matrices est faible, alors l'analyse factorielle exploratoire obtenue est considérée comme bonne et les facteurs latents identifiés permettent bien de réduire l'information proposée. Sinon la structure factorielle des données est à repenser.


Le choix de ces deux méthodes repose globalement sur ce que l'on veut étudier et de ce que l'on veut faire de la variance. Si on considère qu'il n'y a pas de facteur latent et que l'on souhaite conserver le maximum de la variance de nos données alors l'ACP est un choix tout à fait pertinent. En revanche, si on envisage une structure sous-jacente à nos données et donc la présence de facteurs latents et que l'on estime qu'il n'est pas forcément nécessaire de conserver toute la variance de nos données, mais uniquement celle qui est partagée entre nos variables, alors l'AFE sera le bon choix.


## Limites de l'AFE

Comme toutes les méthodes d'analyse de données l'AFE comporte des limites.
La limite majeure de l'AFE, c'est que cette méthode est plus efficiente avec des variables continues. Il est tout-à-fait possible de l'utiliser avec des variables ordonnées  : catégories qui suivent un ordre, (par ex. de *1. "Pas du tout d'accord"* à *5. "Tout-à-fait d'accord"*) en traduisant chaque catégorie par un score. On peut également réaliser ce type d'analyse avec des variables catégorielles (catégories sans échelle de valeur entre elles par ex. : profession), mais il faudra alors être beaucoup plus prudent sur l'interprétation. Et selon les cas, il peut être plus pertinent d'utiliser une autre méthode de factorisation comme l'analyse factorielle des correspondances (AFC) ou une analyse des correspondances multiples (ACM).

La taille de l'échantillon est également un élément contraignant pour ce type d'analyse. Si l'échantillon est trop faible au regard de la taille des informations à synthétiser, les résultats obtenus risquent de surreprésenter les spécifictés de la population alors testée. La structure de l'analyse ne sera pas généralisable, mais influencée par les spécificités de l'échantillon. Il est donc important d'avoir une taille d'échantillon suffisamment importante afin de pallier ce type de biais (Young and Pearce 2013).

Des corrélations trop fortes ou trop faibles entre les variables peuvent mettre en péril la mise en facteur des informations, mais pas pour les mêmes raisons. 
Si le set de variables soumis à la factorisation n'est pas du tout corrélé, alors les éléments présentés ne partagent pas d'éléments communs et ne peuvent pas être résumés sous un même facteur. L'hétérogénéité des informations peut tout-à-fait empêcher son résumé statistique via l'utilisation des analyses factorielles. Il n'est pas possible de réaliser des analyses factorielles sur des ensembles de variables non-corrélées.
A l'inverse, si les variables retenues pour l'analyse sont trop fortement corrélées alors ceci sous-tend qu'elles contiennent des informations tellement similaires qu'elles en sont redondantes. Cette redondance peut tout-à-fait biaiser la factorisation des informations, car certains éléments seront surreprésentés - sans que cela ne reflète une quelconque réalité - par rapport à d'autres. Ce problème peut être résolu en sélectionnant uniquement l'une des deux variables représentatives d'un même phénomène. Par exemple, la catégorie socio-professionnelle et le niveau de diplôme sont généralement très corrélés, il faudra sélectionner l'une de ces deux variables dans le modèle d'analyse factorielle pour que celui-ci soit optimal (Tabachnick, B., & Fidell, L., 2014).

La subjectivité de l'interprétation peut aussi être une limite, notamment sur l'identification et l'interprétation des facteurs latents, qui dépendra beaucoup du chercheur et de son positionnement théorique.

# Les packages

```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(correlation, corrplot, dplyr, EFA.dimensions, ggraph, ggplot2, lavaan, nFactors, parallel, parameters, psych, RColorBrewer, rrcov, see, table1, usdm)

```

A quoi servent ces différents packages ? :

- *[pacman](https://cran.r-project.org/web/packages/pacman/index.html)* : est un package de management de packages.

- *[here](https://cran.r-project.org/web/packages/here/index.html)* : permet de gérer les chemin d'accès au ein de notre projet

- les packages *[correlation](https://cran.r-project.org/web/packages/correlation/index.html)* et *[corrplot](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html)* permettent de réaliser des corrélations et des graphiques tels que des corrélogrammes.

- *[dplyr](https://cran.r-project.org/web/packages/dplyr/index.html)* est un package de manipulation de données.

- Les packages *[EFA.dimensions](https://cran.r-project.org/web/packages/EFA.dimensions/index.html)*, *[nfactors](https://cran.r-project.org/web/packages/nFactors/index.html)*, *[psych](https://cran.r-project.org/web/packages/psych/index.html)* et *[parallel](https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf)* sont des packages utilisés pour vérifier si les données sont factorisables grâce à différents indices statistiques (KMO, etc.). Ils permettent également de déterminer le nombre de facteurs optimal à retenir selon le set de données soumis à l'analyse.

- *[ggraph](https://cran.r-project.org/web/packages/ggraph/index.html)*,  *[ggplot2](https://cran.r-project.org/web/packages/ggplot2/index.html)*,  *[RColorBrewer](https://cran.r-project.org/web/packages/RColorBrewer/index.html)* et *[see](https://cran.r-project.org/web/packages/see/index.html)* sont des packages dédiés à la production de représentations graphiques.

- Le package *[lavaan](https://lavaan.ugent.be/)* permet de réaliser des modèles statistiques impliquant des variables latentes, telles qu'elles existent dans les Analyses factorielles exploratoires et confirmatoires.

- Les packages *[parameters](https://cran.r-project.org/web/packages/parameters/index.html)*, et *[table1](https://cran.r-project.org/web/packages/table1/vignettes/table1-examples.html)* sont utilisés dans cette fiche pour réaliser des statistiques descriptives et des mises en forme de sortie exploitables directement.

- Le package *[rrcov](https://cran.r-project.org/web/packages/rrcov/index.html)* permet de détecter les multioutliers d'un jeu de données en se basant sur la méthode MCD. 

- Le package *[usdm](https://cran.r-project.org/web/packages/usdm/usdm.pdf)* comprend différentes fonction permettant d'explorer l'impact de différentes sources d'incertitudes dans des mesures d'association. Nous utiliserons surtout les fonctions permettant de mesurer la multicolinéarité entre des variables.

- Le package *[effectsize](https://cran.r-project.org/web/packages/effectsize/index.html)* pour interpréter les coefficients de l'analyse factorielle confirmatoire

- Les packages *[semPlot](https://cran.r-project.org/web/packages/semPlot/index.html)* et *[semTools](https://cran.r-project.org/web/packages/semTools/index.html)* pour réaliser des equations structurelles méthode à laquelle appartient l'analyse factorielle confirmatoire


# Les données

L'idée de cet article est de présenter l'analyse factorielle exploratoire et de voir comment elle peut constituer une alternative à l'analyse en composante principale.
L'AFE est très utilisée en psychologie, mais beaucoup moins dans d'autres disciplines des SHS. Pour illustrer l'intérêt de ces méthodes en dehors de la psychologie, dans un premier temps nous utiliserons des données issues  de travaux en géographie et dans un deuxième temps de données démographiques. Ces dernières portent sur l'ensemble des pays du monde et sont publiées dans le cadre du bulletin d'information scientifique "Population et Société" produit par l'INED. Dans les deux cas la dimension spatiale de ces données ne sera pas exploitée, ce n'est pas l'objectif des analyses factorielles. Dans un troisième temps, une analyse factorielle exploratoire sera réalisée sur des données provenant de recherches en Psychologie.


<br/>

<p class="center">[<span style="font-size: 230%;" class="glyphicon glyphicon-download-alt"></span> <br/> Télécharger les données](https://rzine.fr/docs/20230425_geomorphon/data.zip)</p>

<br/>


# Mise en pratique : exemple du prix de l'immobilier en France hexagonale

Les données du prix de l’immobilier par EPCI (prix médian au m²) sont issues des ventes observées sur l’année 2018, extraites depuis la base de données des notaires de France par Frédéric Audard et Alice Ferrari. Ce fichier a été simplifié pour ne conserver que les variables d’intérêts parmi une cinquantaine
Les données statistiques proviennent de l’INSEE (année 2019) : 9 variables ont été choisies pour leur potentialité à expliquer les variations des prix de l’immobilier, concernant la population, le logement et les revenus et niveaux de vie.

Ce fichier est composé des 9 variables suivantes :

- prix_med : prix médian par EPCI à la vente au m²
- perc_log_vac : % logements vacants
- perc_maison : % maisons
- perc_tiny_log : % petits logements
- dens_pop : densité de population
- med_niveau_vis : médiane du niveau de vie
- part_log_suroccup : % logements suroccupés
- part_agri_nb_emploi : % agriculteurs
- part_cadre_profintellec_nbemploi : % cadres et professions intellectuelles

```{r, echo = TRUE}

# Chargement des données de base

library(here)
csv_path <- here("data", "immo_afe.csv")

immo <- read.csv2(csv_path, row.names=1)


### Centrer et réduire les variables
dfz <-  data.frame(scale(immo, center=T, scale=T))
```

Il est extrêmement recommandé de centrer-réduire ses données pour réaliser une analyse statistique telle qu'une analyse factorielle, ou plus généralement lorsque l'on travaille avec des variables n'étant pas sur les mêmes échelles, sur les mêmes ordres de grandeurs. Cela implique de faire subir à nos données une transformation statistique visant à ce qu’elles aient une moyenne de 0 et un écart-type de 1. On parle aussi en statistique de standardisation. Cette transformation permet de conserver la variabilité de nos données (la distance entre chaque valeur reste inchangée), tout en les rendant comparables (elles sont placées sur une même échelle). Dans le cadre de modélisations statistiques, il est nécessaire de réaliser cette opération sur les variables explicatives du modèle. Sur R on peut facilement réaliser cette opération avec la fonction `scale()` - que nous utilisons dans notre exemple - ou à “la main”. L’opération est simple : on soustrait chaque valeur par la moyenne puis on divise chaque valeur par l’écart-type. 



La première étape étant toujours la description des données, voici un tableau récapitulatif de nos variables : 

```{r, echo = TRUE}

table1(~ prix_med + perc_log_vac + perc_maison + perc_tiny_log + dens_pop + med_niveau_vis + part_log_suroccup + part_agri_nb_emploi + part_cadre_profintellec_nbemploi , data=immo) 

```

La réalisation des représentations graphiques permet d'appréhender les distributions de nos variables et leurs éventuelles spécificités.

```{r, echo = TRUE}
dfgraph<-subset(immo, select = c(prix_med, perc_log_vac, perc_maison, perc_tiny_log, dens_pop, med_niveau_vis, part_log_suroccup, part_agri_nb_emploi, part_cadre_profintellec_nbemploi))

par( mfrow= c(3,3) )

h1 <- hist(dfgraph$prix_med, main=NULL)
h2 <- hist(dfgraph$perc_log_vac, main=NULL)
h3 <- hist(dfgraph$perc_maison, main=NULL)
h4 <- hist(dfgraph$perc_tiny_log, main=NULL)
h5 <- hist(dfgraph$dens_pop, main=NULL)
h6 <- hist(dfgraph$med_niveau_vis, main=NULL)
h7 <- hist(dfgraph$part_log_suroccup, main=NULL)
h8 <- hist(dfgraph$part_agri_nb_emploi, main=NULL)
h9 <- hist(dfgraph$part_cadre_profintellec_nbemploi, main=NULL)
```

```{r message=FALSE, warning=FALSE, include=FALSE}

dev.off()

```

## Les pré-requis de l'analyse factorielle

Comme toutes les méthodes statistiques les analyses factorielles ont un certain nombre de pré-requis à vérifier. Ne pas en tenir compte nous expose à des résultats biaisés voire complètement erronés.

### Les Outliers : comment les gérer ?

<div class="alert alert-danger" role="warning">
La question du traitement de ces individus extrêmes est loin d'être simple. Elle doit faire l'objet d'une réflexion et de choix importants qu'il faut pouvoir assumer tant statistiquement que théoriquement.</div>

Les outliers sont nos individus extrêmes. Il est toujours nécessaire de pouvoir les identifier afin de savoir comment les gérer. L'enjeu autour de ces individus c'est qu'ils vont nécessairement influencer (voire fausser) les résultats de nos analyses. L'analyse obtenue sera différente si on fait le choix de les supprimer ou de les conserver (Zijlstra et al. 2011).

#### La méthode MCD :

Il existe un grand nombre d'indicateurs et de distances différentes qui permettent d'identifier des outliers. Afin de choisir la bonne méthode, il est important de se rappeler dans quel contexte nous nous trouvons et quelle analyse nous souhaitons réaliser.

Dans le cadre des analyses multivariées, au sein duquel nous nous trouvons avec les différentes analyses factorielles, il est nécessaire de rechercher les multioutliers. Ce sont des valeurs extrêmes sur l'ensemble des variables de notre échantillon de variables. Certains individus peuvent ne pas avoir de caractéristiques extrêmes lorsque celles-ci sont étudiées séparément, mais se révéler être très différents du reste de l'échantillon sur un pattern de variables. Dans le cadre des analyses multivariées, il est essentiel de s'assurer que de telles particularités ne viennent pas perturber la qualité des résultats obtenus. Ne pas retirer les valeurs extrêmes expose à centrer l'analyse des résultats sur la distance entre cette valeur très différente du reste de l'échantillon et les autres valeurs. Ceci donc au détriment des variabilités qui pourraient être contenues dans le reste de l'échantillon. Ces variabilités seront donc écrasées, et paraitront donc bien minimes face à la distance émise par la ou les valeurs extrêmes.  

Il existe de nombreuses méthodes pour identier ces individus extrêmes. Une méthode robuste qui fait consensus dans le cadre de données multidimensionnelles (c'est à dire corrélées entre elles) est la méthode MCD. Elle a été théorisé par Christophe Leys et ses collaborateurs en 2018 (Leys et al. 2018). Cette distance est elle même basée en partie sur la distance de Mahalanobis, et sa variante, la Mahalanobis robuste, qui ont été développées respectivement par Prasanta Chandra Mahalanobis en 1936 (Mahalanobis, C., P, 1936) et Gnanadesikan & Kettenring en 1972 (Gnanadesikan, R. & Kettenring, J. R., 1972).

La distance de Mahalanobis se base sur la moyenne et la covariance de tous les individus de notre base de données y compris les outliers. Cette distance est donc elle même très influencée par nos individus extrêmes. Cela pose donc une question sur la réelle identification des outliers. Leys et al. proposent donc une nouvelle méthode qui repose sur le calcul des paramètres du sous-ensemble de notre base de données qui a été défini comme étant le plus central. Ce sous-ensemble est issu d'une itération permettant de déterminer quel sous-ensemble peut être considéré comme le plus central. 

#### Identification des Outliers avec la méthode MCD :

Pour utiliser cette méthode il existe plusieurs packages comme notamment `performance`, `robustbase` ou encore `rrcov`. Ces trois packages sont sur le cran et permettent de calculer efficacement la distance entre nos données avec la méthode MCD.
Avant de débuter le calcul il est très important de savoir qu'une des limites majeures de cette méthode est qu'elle ne peut pas gérér les valeurs manquantes dans nos bases de données. Elle ne fonctionne que sur des données complètes, il faudra donc imputer les données manquantes ou les supprimer en amont.
La fonction CovMcd du package `rrcov` peut tourner avec des données manquantes, elle les gère en les supprimant. Nous faisons le choix de présenter cette méthode dans un premier temps notamment pour ses sorties graphiques qui peuvent s'avérer être des aides efficaces à l'identification des outliers.


```{r, echo = TRUE}

#MCD avec le package rrcov
library(rrcov)
# 1- calcul de la distance MCD
mcd_result <- CovMcd(dfz, alpha=0.75)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
plot(mcd_result, which="all")

```

1- Distance-Distance plot : Diagrame de distance entre la méthode MCD et la distance de Mahalanobis

2- Distance plot : Diagramme de Distance de la méthode MCD

3- X² QQ-Plot : diagramme Quantile-Quantile qui permet d'évaluer la pertinence de l'ajustement d'une distribution donnée à un modèle théorique. Ici l'ajustemet de la méthode MCD à la distribution théorique du X².

4- Scree plot : comparaison des valeures propres entre la méthode robuste et classique.


Le package `performance` permet également d'identifier directement les outliers ainsi que de synthétiser l'information dans un data frame. Ceci peut s'avérer très utile pour manipuler les données, par exemple isoler facilement les outliers et les travailler spécifiquement. En revanche, les visualisations issues de `performance` ne sont pas très lisibles quand il y a de nombreux outliers.

```{r, echo = TRUE}
# MCD avec le package performance

library(performance)
# 1- calcul de la méthoe MCD
out<-check_outliers(dfz, method = "mcd", thresold = 0.75)
#2- Affichage des résultats
out

# 4- Mise en data frame
outliers_info <- as.data.frame(out)

head(outliers_info)

# row : l'identifiant de la ligne correspondant dans le dataframe immo.
# Distance_MCD : la distance calculée selon la méthode MCD, plus elle est importante plus l'individu est extrême
# Outlier_MCD : probalité que l'individu soit un outlier selon la méthode MCD.1 l'individu est un outlier, 0 ce n'est pas le cas.
# Outlier : l'individu est-il un outlier. 1 oui et 0 non

# Pour éventuelement avoir tous nos outliers
filtered_data <- dfz[outliers_info$Outlier_MCD >0, ]

dfz$Row <- seq_len(nrow(dfz))
dfz$name<- rownames(dfz)

data <- merge(dfz, outliers_info, by = "Row")

dfz$Row <- NULL
dfz$name <- NULL

# Exemple de visualisation avec ggplot

# ind_outlier <- filter(outliers_info, outliers_info$Outlier_MCD == 1)

  #ggplot(ind_outlier)+
  #    geom_bar(aes(x=reorder(Row, Distance_MCD), y=Distance_MCD),fill = "#112446", stat = "identity") +
  #    coord_flip() + theme_minimal()

```

Nous avons donc ainsi calculé pour chaque ligne sa distance selon la méthode MCD. On note dans notre cas qu'un individu se détache particulièrement. Il s'agit de l'EPCI de la ligne 266 avec l'identifiant 200054781.

Cette étape d'identification est essentielle car lourde de conséquences.

Que faire des outliers ? Les conserver en prenant le risque qu'ils biaisent nos résultats ou les retirer mais en perdant le sens de notre analyse ?

Par exemple, dans notre cas, cet individu de la ligne 266 correspond au grand Paris. Il devient beaucoup plus aisé de comprendre pourquoi cet individu est aussi particulier (nous rappelons qu'il y a le prix de l'immobilier au m² dans nos variables), mais aussi des enjeux de le supprimer ou non de notre analyse. Le supprimer c'est retirer le grand Paris de note analyse des prix de l'immobilier en France hexagonale.

Pour cet article nous faisons le choix de le supprimer de notre analyse. Nous cherchons à mettre en évidence les facteurs latents, s'exprimant par nos variables mesurées, qui caractérisent les EPCI de la France Hexagonale. Or malheureusement si nous conservons le grand Paris nous nous exposons à ne pas observer la variabilité des différentes EPCI de l'haxagone, mais uniquement de la distance entre le grand Paris et les autres EPCI de notre base de données. En effet, le grand Paris étant tellement éloigné des autres EPCI sur l'ensemble des variables de notre base de données que celui-ci écrase les variabilités entre les autres communes. Afin de pouvoir faire émerger une structure factorielle qui ait du sens entre nos EPCI, nous faisons le choix de sortir le grand Paris de notre base de données.

<div class="alert alert-warning" role="alert">
Attention, la suppression des outliers entraîne des considérations théoriques. Supprimer une observation telle que le Grand Paris n'est pas anodin sur l'analyse des résultats concernant le prix de l'immobilier en France hexagonale. Toutefois, laisser une telle observation empêche sa lecture selon nos hypothèses, car le focus serait fait sur la distance entre le Grand Paris et le reste de nos données, alors que ce n'est pas notre question. S'il ne paraît pas justifiable théoriquement de supprimer cette observation, alors le choix de la méthode statistique doit être questionné. Elle n'est peut-être pas la plus adaptée pour traiter les données et répondre aux hypothèses alors formulées.
</div>


Nous supprimons donc le grand Paris de notre base de données :

```{r, echo = TRUE}
dfzp <- dfz[!(row.names(dfz) %in% c("200054781")), ]
```

A présent, vérifions si d'autres multioutliers se détachent au sein de notre base de donnée. En théorie, il faut répéter cette opération plusieurs fois, jusqu'à ce que l'on observe une homogénéité des données et une abscence de valeurs extrêmes.

```{r, echo = TRUE}

#MCD avec le package rrcov
library(rrcov)
# 1- calcul de la distance MCD
mcd_resultp <- CovMcd(dfzp)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
plot(mcd_resultp, which="all")


```

Contrairement à l'exemple précédent, avec la présence du Grand Paris, les représentations graphiques indiquent que si des valeurs se détachent et pourraient tout-à-fait être considérées comme extrêmes, elles restent proches du reste de l'ensemble de données. La distance n'est donc pas aussi importante entre les EPCI qu'avec la présence du Grand Paris. Il faudra conserver cette information lors de l'analyse des résultats qui seront donc à interpréter avec précaution.

Vérifions si les distributions de nos variables ont été impactées par cette suppression.

```{r, echo = TRUE}
par( mfrow= c(3,3) )

h1_1 <- hist(dfzp$prix_med, main=NULL)
h2_1 <- hist(dfzp$perc_log_vac, main=NULL)
h3_1 <- hist(dfzp$perc_maison, main=NULL)
h4_1 <- hist(dfzp$perc_tiny_log, main=NULL)
h5_1 <- hist(dfzp$dens_pop, main=NULL)
h6_1 <- hist(dfzp$med_niveau_vis, main=NULL)
h7_1 <- hist(dfzp$part_log_suroccup, main=NULL)
h8_1 <- hist(dfzp$part_agri_nb_emploi, main=NULL)
h9_1 <- hist(dfzp$part_cadre_profintellec_nbemploi, main=NULL)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
dev.off()
```


### Analyse de la matrice de corrélation

L'analyse des corrélations est une étape toujours essentielle dans l'analyse de données, et notamment dans le cadre de la modélisation statistique.

Cette étape est fondamentale pour plusieurs raisons. D'abord car elle nous permet d'étudier les relations entre nos variables, ce qui va nous donner des indications sur le meilleur modèle pour nos données.
En effet, des corrélations trop fortes ou à l'inverse une absence totale de corrélation peut poser de nombreux problèmes comme nous l'avons évoqué précédemment. Par exemple:

- *La multi-colinéarité* : Lorsque des variables sont trop fortement corrélées (positivement ou négativement) cela pose un problème de multi-colinéarité. Les  variables sont tellement liées qu'il devient difficile de distinguer leur impact individuel, cela va rendre les résultats peu fiables. Il deviendra compliqué d'interpréter les coefficients et de comprendre de quoi rend-il vraiment compte.
- *Des risques de surajustement* : Un modèle avec des prédicteurs trop fortement corrélés va être surajusté et donc ne sera pas pertinent dans son rôle prédictif.
- *Une instabilité du modèle* : Les modèles avec des variables trop fortement corrélées sont instables. La moindre variation dans les données pourra provoquer de très grandes variations dans les résultats.
- *Un modèle non optimisé* : Un modèle doit respecter le principe de parcimonie. Il ne faut pas qu'il contienne de variables redondantes (corrélations trop fortes) ou inutiles (absence de corrélations).
- *Un modèle nul* : Une absence totale de corrélations remet en question la pertinence de tester, dans un même modèle, des variables qui n'auraient donc aucun rapport entre elles.

Comme nous avons pu l'observer précédemment avec les histogrammes des distributions de nos variables, celles-ci ne suivent pas une loi normale. Le coeficient de corrélation de Pearson n'étant pas stable sur des données non-normales, nous lui préfererons celui de Spearman pour faire notre matrice. 

```{r, echo = TRUE}

# Matrice de corrélation
cor <- correlation(dfzp, method = "spearman")
cor %>%
  summary(redundant = FALSE)

```

La matrice obtenue indique que l'ensemble de nos variables sont corrélées. Nous ne sommes pas en présence d'une hétérogénéité d'informations. Nous pouvons donc rechercher une structure sous-jacente à cet ensemble de variables qui partagent une part de variance commune entre-elles et donc réaliser uen analyse factorielle.

Toutefois, on observe entre certaines variables des corrélations fortes, notamment entre la part de logement sur-occupés (`part_log_suroccup`) et le pourcentage de maisons (`perc_maison`) avec un coefficient de -0.75. Ou encore entre le pourcentage de logements sur-occupés et le pourcentage de petits logements (`perc_tiny_log`) avec un coefficient de corrélation de 0.80.
La question à se poser est de savoir s'il est absolument nécessaire de conserserver toutes ces variables. Apportent-elles toutes une part d'information singulière ou est-on en présence de redondance d'information entre nos variables ? Bref leur co-présence dasn notre modèle n'est-elle pas source de biais?

Pour faire ce choix il faut appliquer le principe de parcimonie. Ce principe indique qu'entre deux choix qui expliquent de manière adéquate les observations, il faut tendre vers le modèle le plus simple et le moins complexe.

Ici nous faisons le choix de conserver toutes les variables, bien que très corrélées, nous estimons qu'elles ne renvoient pas à la même information et souhaitons les conserver dans notre modèle. 

Vérifions tout de même si nous ne sommes pas en présence d'une multicolinéarité. C'est-à-dire que plusieurs variables partagent une part de variance importante, ce qui peut amener à sur-représenter un phénomène et biaiser les résultats lors d'une analyse factorielle exploratoire. Afin de vérifier la multicolinéarité entre nos variables nous utiliserons le VIF *Variance Inflation Factor*. Cet indice est habituellement utilisé pour des modèles de régressions, toutefois Kyriazos & Poga ont démontré son utilité dans le cadre des analyses factorielles (Kyriazos & Poga, 2023). 

```{r, echo = TRUE}
vifstep(dfzp, method = "spearman")
```

Bien que la fonction ne nous signale aucun problème de multicolinéarité, nous observons toutefois 2 VIF supérieurs à 5. Celui sur la variable représentant la part des logements sur-occupés et celui sur le pourcentage de petits logements. Le seuil à retenir pour considérer la présence de multicolinéarité ou non à l'aide du VIF ne fait pas l'unanimité parmi les statisticiens. Dans notre exemple, nous nous basons sur la démonstration de Farrar & Glauber qui préconise un seuil de 5 (Farrar & Glauber, 1967).
Nous choisissons donc de sortir la variable renseignant la part de logements sur-occupés. Après vérification sur ce nouveau set de variable, les VIF obtenus sont tous inférieurs à 5, nous pouvons conclure en faveur d'une absence de multicolinéarité entre nos 8 variables. 

```{r, echo = TRUE}
dfzpp<-subset(dfzp, select = -c(part_log_suroccup))
vifstep(dfzpp, method = "spearman")
```



### KMO et Sphéricité

Avant de factoriser nos données et de rechercher une structure sous-jacente, il est nécessaire de vérifier la présence d'un minimun de corrélation entre nos variables. Ce que nous avons fait précédemment. En effet, dans le cas où les corrélations sont très faibles ou inexistantes, il sera très difficile de faire émerger un ou des facteurs. L'AFE ne sera donc probablement pas l’analyse à conseiller.  

Ensuite, il faut mesurer l'adéquation de l'échantillonnage. Cette mesure donne un aperçu global de la qualité des corrélations inter-items (inter-variables). Pour ce faire on va utiliser l'indice KMO. L’indice KMO  varie entre 0 et 1 et donne une information complémentaire à l’examen de la matrice de corrélation. 
Cet indice est calculé pour l'ensemble de nos variables, mais aussi pour chaque variable.
Un KMO élevé indique que les variables sont suffisamment corrélées pour justifier l'utilisation de l'AFE. En revanche, un KMO bas suggère que l'analyse factorielle pourrait ne pas être appropriée avec les données fournies.

<div class="alert alert-success" role="warning">
L'interprétation du KMO a été décrite par Kaiser en 1974 et se décline ainsi (Kaiser, 1974) : 

- 0.90 et plus : Merveilleux
- 0.80 et plus : Méritoire
- 0.70 et plus : Bien
- 0.60 et plus : Médiocre
- 0.50 et plus : Misérable
- Moins de 0.50 : Inacceptable</div>

On peut tout-à-fait avoir le cas d'un KMO global élevé indiquant une bonne adéquation générale, mais un KMO d'une variable en particulier très mauvais. Dans ce cas de figure il faut examiner la variable pour essayer de comprendre pourquoi son KMO est faible. Cela peut venir de valeurs manquantes, d'une faible variance, ou encore d'une mauvaise corrélation avec les autres variables. Cette variable peut empêcher au modèle d'être mis en lumière correctement et provoquer du bruit. Il faudrait donc envisager de la retirer du modèle. 

Il faut également vérifier que notre matice de corrélation n'est pas une matrice d'identité. C'est-à-dire une matrice de corrélation où toutes nos variables sont parfaitement indépendantes, à savoir où toutes les corrélations sont égales à 0. Pour celà nous utilisons le test de sphéricité de Bartlett (Bartlett, M.S., 1937).
Pour valider ce pré-requis il est nécessaire que le test soit significatif (p < 0,05) pour accepter l'idée que notre matrice de corrélation est significativement différente d'une matrice d'identité.

Pour réaliser un KMO et le test de Bartlett on peut utiliser la librairie `psych` avec les fonctions `KMO()` et `cortest.bartlett()`.
Une alternative intéressante est la fonction `check_factostructure()` du package `performance`, cette fonction réalise les deux tests et nous indique si nos données sont appropriées pour réaliser une analyse factorielle.

```{r, echo = TRUE}

#Avec psych
## KMO
KMO(dfzpp)
## Test de sphéricité
cortest.bartlett(dfzpp, n=1222)


# Avec performance
performance::check_factorstructure(dfzpp)

```

Dans notre cas nous avons donc un KMO global méritoire (0.81) et des KMO par variable satisfaisants. Le test de sphéricité nous indique que notre matrice de corrélation n'est pas une matrice d'identité. Nous pouvons donc nous lancer dans l'AFE!

## Combien de facteurs retenir ?

Lorsque l'on procède à une analyse factorielle il est très souvent nécessaire de définir le nombre de composantes que l'on souhaite (pour l'ACP) ou de facteurs latents (AFE) en amont. Cette décision repose sur l'étude des valeures propres et il existe un grand nombre d'indices et de méthodes (comme par exemple *le coude* de Katell, la règle de Kaiser-Guttman...). Cependant, il n'existe pas de consensus sur quelle méthode choisir et laquelle serait la plus appropriée selon les cas.

Makowski en 2018, propose de se reposer sur un consensus parmi les méthodes plutôt que sur une méthode en particulier (Makowski, 2018). Il implémente sa solution dans le packge `psycho` puis dans la fonction`n_factors()` dans le package `parameters`. C'est ce que nous utiliserons ici pour définir le nombre adéquat de facteurs à retenir pour notre analyse.

```{r, echo = TRUE}
# Identification du nombre de facteurs
library(parameters)
n <- n_factors(dfzpp)
n

# Plus de détail peuvent être obtenu en pasant au format data frame et en utilisant summary()

nb_factor <- as.data.frame(n)

head(nb_factor)

summary(n)

# On peut également représenter le nombre de facteurs.
library(see)
plot(n, type="line") + theme_modern()

# et visualiser le graphique des valeures propres
SCREE_PLOT(dfzpp, corkind="spearman", verbose=T)

```

Ici on voit très clairement qu'il est nécessaire de creuser un peu plus loin. Les résultats bruts renvoient un seul facteur latent, ce qui peut être tout à fait logique vu le petit nombre de variables que nous avons. C'est aussi une des forces de l'AFE de pouvoir faire émerger un seul facteur latent global au sein duquel se projeterait toutes nos variables. C'est un résultat qui peut être très intéressant.

Toutefois, on voit également que 6 méthodes font également consensus sur deux facteurs latents. 

**Ainsi quel est le meilleur modèle ?**

L'analyse factorielle confirmatoire que nous allons vous présenter par la suite va nous permettre de décider. En attendant, nous pouvons lancer les deux analyses !

Pour réaliser ces analyses il va falloir déterminer la méthode de factorisation. C'est-à-dire définir sur quelle mesure on se base pour extraire les facteurs de notre set de variables. Les méthodes les plus courament utilisées sont celles qui se basent soit sur le maximum de vraisemblance (maximum likelihood), soit sur les méthodes des moindres carrés (pondérés ou non) (weighted or unweighted least square) (Tabachnick, B. G., & Fidell, L. S., 2014). Dans notre exemple, après observation des distributions de nos données, nous avons choisi de réaliser nos analyses avec la méthode de factorisation du maximum de vraisemblance robuste (mlr). Cette méthode permet d'optimiser le calcul des distances et la version robuste est adaptée à des données non normales (Kyriazos & Poga, 2023). 

<div class="alert alert-warning" role="alert">
Aparte sur les rotations :

Afin de pouvoir interpréter plus facilement les résultats des analyses factorielles, il est nécessaire de faire appel à une méthode de rotation (au-delà de 2 facteurs). Le principe de la rotation n'est pas de modifier les relations obtenues entre les variables observées et les facteurs, mais d'améliorer la lisibilité des résultats.

Il existe deux familles de rotation. Les rotations orthogonales et les rotations obliques. Les rotations orthogonales doivent être privilégiées lorsque l'on émet l'hypothèse que les facteurs (ou composantes) obtenus ne sont pas corrélés entre eux. Pour cette famille de rotation l'interprétation va se centrer sur la relation de chaque variable observée avec chaque facteur. Au contraire, les rotations obliques devront être employées s'il est supposé que les facteurs obtenus sont corrélés entre eux.
Dans ce dernier cas, en plus de la matrice de corrélation calculée pour les rotations orthogonales, une matrice supplémentaire incluant les corrélations entre les facteurs va être produite. Il est à noter qu'en SHS la plupart des factorisations impliquent une corrélation entre les facteurs. Il est assez rare d'obtenir des facteurs qui ne soient pas du tout corrélés dans ces disciplines. C'est pourquoi dans notre exemple nous avons sélectionné une méthode de rotation oblique *promax*.
</div>

## Lancement des AFE

**1er modèle à un 1 facteur :**

```{r, echo = TRUE}

# Utilisation de mlr méthode considérée comme plus robuste même pour des données non-normales

# Pour avoir mlr il faut utiliser la syntaxe ci-dessous :
# Nous n'utilisons pas de méthode de rotation car nous testons la solution à 1 seul facteur
efa1immo <- lavaan::efa(dfzpp, nfactors = 1, estimator = "MLR")

print(efa1immo)

```

Avec un seul facteur toutes nos variables corrèlent donc avec un facteur latent. 
Dans notre cas on a toute une partie qui corrèle positivement et l'autre négativement. Ainsi, le pourcentage de petit logements, la part des cadres dans l'emploi, le prix median du m², la densité de population et le niveau de vie médian corrèlent positivement et à l'inverse, le pourcentage de maison, la part d'agriculteurs dans l'emploi et le pourcentage de logements vacant corrèlent négativement. Cela laisse à penser à une dichotomie qui serait ville / campagne. Ainsi le facteur latent exprimé par nos huit variables qui caractérisent nos EPCI, serait une dimension sur le niveau d'urbanité ou de ruralité.

L'avantage de l'AFE c'est qu'une fois le facteur latent identifié, nous pouvons, pour chaque individu obenir un score sur ce facteur latent. Dans notre exemple, vu la dimension spatiale des données il faudrait ensuite les cartographier pour visualiser spatialement l'information. L'intérêt des scores factoriels étant d'être ré-utilisés soit dans des analyses complémentaires, soit directement pour comprendre la structure de nos données. Dans notre cas, on pourrait s'en servir pour définir un score d'urbanité et de ruralité puis le représenter

```{r, echo = TRUE}
# Extraction des scores factoriels par observation
factor_scores_immo<-predict(efa1immo)

# Regardons  les 5 premières lignes
head(factor_scores_immo, 5)

# Extraction des charges factorielles par variable
factor_loadings_immo <- efa1immo$loadings

# Afficher les charges factorielles
print(factor_loadings_immo)
```

**Testons le modèle à deux facteurs !** 

```{r, echo = TRUE}

# Utilisation de mlr méthode considérée comme plus robuste même pour données non-normales
# Utilisation d'une méthode de rotation promax car nous testons un modèle à2 facteurs

efa2immo <- lavaan::efa(dfzpp, nfactors = 2, estimator = "MLR", rotation = "promax")
loads2immo<-print(efa2immo)
loads2immo
```

Cette structure à deux facteurs est également très intéressante, et a permis de faire émerger en plus du facteur latent, qui serait urbanité/ruralité, un autre facteur représentant le côut de la vie. Au niveau de ce facteur on observe une corrélation positive avec le prix médian de l'immobilier au m² et le niveau de vie médian, et négative avec le pourcentage de logement vacant. Ainsi, les EPCI ayant un score élevé sur ce facteur latent seraient les EPCI où le niveau de vie médian et le prix de l'immobilier seraient le plus élévés.

Extraction des charges factorielles par variable :
```{r, echo = TRUE}

factor_loadings_immo2 <- efa2immo$loadings

# Afficher les charges factorielles
print(factor_loadings_immo2)
```

Une fois de plus nous pouvons extraire les scores de ces deux facteurs latents de ce second modèle.
```{r, echo = TRUE}
# Extraction des scores factoriels par observation
factor_scores_immo2<-predict(efa2immo)

# Regardons  les 5 premières lignes
head(factor_scores_immo2, 5)

```

Il est tout à fait possible dans le cadre de l'AFE d'emprunter une représentation classique de l'ACP (le scatter plot) pour représenter nos variables et leurs charges factorielles. Cette représentation peut s'avérer également utile pour mieux comprendre nos facteurs latents.

```{r, echo = TRUE}
# Graphique


# Extraire les charges factorielles
factor_loadings_immo2 <- efa2immo$loadings

# transformer les charges factorielles dans un data frame
factor_loadings_dfimmo2 <- as.data.frame(factor_loadings_immo2)

# Renommer les colonnes
colnames(factor_loadings_dfimmo2) <- c("Factor", "Loading")

#  Ajouter une variables pour identifier nos charges factorielles
factor_loadings_dfimmo2$Item <- rownames(factor_loadings_dfimmo2)

# charger ggplot2
library(ggplot2)

# Réaliser un graphique des charges factorielles
ggplot(factor_loadings_dfimmo2, aes(x = Factor, y = Loading, label = Item)) +
  geom_point() +
  geom_text(size = 3, hjust = -0.1) +
  labs(x = "Factor", y = "Loading", title = "Factor Loadings Plot") +
  theme_minimal()

```

<div class="alert alert-danger" role="alert">
Les structures obtenues, suite aux analyses factorielles exploratoires menées, s'ajustent-elles à nos données ? Quel est le meilleur modèle celui à 1 ou 2 facteurs ? Afin de répondre à cette question et d'éprouver notre modèle théorique sur notre échantillon, il est nécessaire de réaliser des analyses factorielles confirmatoires.</div>

# L'Analyse factorielle confirmatoire

L'analyse factorielle confirmatoire est une technique statistique utilisée pour tester un modèle factoriel.

<div class="alert alert-success" role="alert">
**Un modèle factoriel est une représentation mathématique d'une structure sous-jacente explicative des relations observées entre plusieurs variables.**
</div>

Si dans le cas de l'AFE les facteurs latents émergent de manière exploratoire à partir des données, dans le cadre de l'analyse factorielle confirmatoire il s'agira de tester au contraire un modèle avec des hypothèses pré-établies sur nos facteurs latents. Nous allons imposer une structure aux données et étudier dans quelle mesure les données vont correspondre à cette structure prédéfinie.

C'est en ce sens que cette analyse est confirmatoire. Nous étudions comment un modèle pré-établi dans le cadre d'une théorie, ou suite à une première analyse statistique sur des données, est confirmée par les données observées. 

1- *Définir un modèle Préalable* : Spécifier un modèle factoriel a priori, indiquant la relation entre les variables observées et les facteurs latents que nous supposons. Le modèle peut également inclure des relations entre les facteurs latents.

2- *Obtenir les estimations des paramètres* : les différents paramètres de l'analyse factorielle confirmatoire (charges factorielles, covariances entre les facteurs latents...) sont estimés à l'aide de nos données observées. L'objectif de l'analyse étant d'obtenir des estimations qui maximisent l'ajustement entre les données observées et le modèle.

3- *Lire les critères d'ajustement* :  La qualité et l'ajustement du modèle sont évalués en utilisant divers critères statistiques évaluant la position du modèle entre un modèle nul (sans aucun lien) et un modèle saturé (avec des liens très maximum partout). Les indices utilisés sont notamment : le chi², le RMSEA, le CFI, etc.

4- *Interpréter les résultats* : Les charges factorielles indiquent la force et la direction de la relation entre chaque variable observée et son facteur latent correspondant. A partir de ces indications, nous pouvons interpréter les résultats et vérifier si la structure obtenue est bien dans le même sens que celle envisagée.

5- *Modifier le modèle* : Si le modèle ne s'ajuste pas bien (que les indices d'ajustement ne sont pas satisfaisants), des modifications peuvent être apportées, comme la suppression ou l'ajout de liens entre les facteurs et les variables observées, pour améliorer l'ajustement. Attention toutefois à rester dans un cadre théorique cohérent et ne pas tester des liens qui n'ont pas de sens.

Tout l'enjeu en cas de non ajustement du modèle va être de comprendre et d'analyser pourquoi le modèle ne s'ajuste pas. Cela peut venir d'un modèle théorique qui n'est pas adapté aux données observées ou à des variations entre la première analyse, qui permet d'établir un premier modèle, et sa confirmation via l'analyse factorielle confirmatoire.


L'analyse factorielle confirmatoire est donc un très bon complément à l'AFE. Il est d'ailleurs très fréquent que ces deux méthodes soient utilisées ensemble. C'est même plutôt recommandé, tels que l'argumentent Flora & Flake dans un article paru en 2017 (Flora & Flake, 2017).
Il est préférable de ne pas réaliser l'analyse factorielle confirmatoire sur le même jeu de données que l'AFE pour éliminer toute spécificité liée à l'échantillonnage. Néanmoins il est envisageable d'utiliser une partie des données comme échantillon d'entrainement pour identifier des facteurs latents (AFE) et l'autre partie comme échantillon test pour tester le modèle (CFA).
Pour réaliser efficacement le duo AFE/AFC il est nécessaire d'avoir une base de données avec un grand nombre d'individus surtout afin de permettre la création d'un échantillon d'entrainement et de test suffisamment grand. Il est de pratique courante de diviser un échantillon en deux parties de façon aléatoire. Sur une première moitié sera alors réalisée l'AFE et sur la seconde moitié l'AFC. 

## Quel modèle choisir ?

### L'analyse factorielle confirmatoire en pratique

L'analyse factorielle confirmatoire fait partie du champs des équations structurelles, sa mise en oeuvre se fait très bien sur R. L'avantage des équations structurelles c'est qu'à la manière de l'ACP nous pourrons représenter graphiquement les modèles obtenus.

**1- Etape 1 : partitionnement des données :**
```{r, echo = TRUE}

## En premier lien le partitionnement des data
partitions <- datawizard::data_partition(dfzpp, proportion = 0.5) # ici division du corpus eavec 50% des individus dasn l'échantillon d'entrainement
training <- partitions$p_0.5
test <- partitions$test

training$.row_id <- NULL
test$.row_id <- NULL
```

**2- Etape 2 : Réalisation des AFE sur la partition d'entrainement**
```{r, echo = TRUE}

# modèle à 1 facteur
efa1immo_F1 <- lavaan::efa(training, nfactors = 1, estimator = "MLR")


# modèle à 2 facteurs
efa2immo_F2 <- lavaan::efa(training, nfactors = 2, estimator = "MLR", rotation = "promax")

```

**3- Etape 3 : Réaliser une analyse factorielle confirmatoire**
```{r, echo = TRUE}

library(lavaan)

attach(test) # nécessaire à cause du package lavaan

# modèle à 1 facteur
model1F<- 'F1 =~ prix_med + perc_log_vac + perc_maison + perc_tiny_log + dens_pop + med_niveau_vis + part_agri_nb_emploi + part_cadre_profintellec_nbemploi'

fact_1immo <- cfa(model1F, std.lv=T, estimator="MLR", data=test)

# modèle à 2 facteurs
model2F<- 'F1 =~ prix_med + perc_log_vac + med_niveau_vis
           F2 =~ perc_maison + perc_tiny_log + dens_pop + part_agri_nb_emploi + part_cadre_profintellec_nbemploi'
fact_2immo <- cfa(model2F, std.lv=T, estimator="MLR", data=test)

```

**Etape 3 : étudier la convergence de nos deux modèles**

Attention les sorties d'un modèle d'analyse factorielle confirmatoire sont nombreuses, nous les détaillons ici pour en avoir une première lecture mais leurs analyses se feront véritablement à l'aide d'autres fonctions. Il faut retenir que deux grandes étapes seront à évaluer : l'adéquation de nos données au modèle proposé (avec la vérification des indices d'ajustement au modèle) et si le modèle s'ajuste correctement nous pourrons alors étudier la structure de celui-ci par la force et le signe des saturations obtenues. 

```{r, echo = TRUE}
res_fact1immo <- summary(fact_1immo, standardized=T, modindices = T, fit.measures=T, rsquare=T)

# Pour voir les différents éléments qui composent notre summary de notre modèle
summary(res_fact1immo)

resfact2immo <- summary(fact_2immo, standardized=T, modindices = T, fit.measures=T, rsquare=T)
```

- header : contient des éléments contextuels sur notre fonction (version du package...) ainsi que les mesures d'ajustement si `fitMeasures=TRUE`
- optim : liste d'information concernant l'optimisation du modèle
- data : des éléments sur nos données
- test : les résultats des différents tests
- fit : Résultats des différents test d'ajustement du modèle
- pe : les différents paramètres des relations au sein du modèle sous la forme d'un data frame des facteurs latent et de la variance
- mi: si modindices=TRUE, il s'agit des suggestions proposées par la foncions pour améliorer notre modèle

Voici donc la sortie brute de summary, on retrouve également les R2

```{r, echo = TRUE}
#exemple pour le modèle à 1 facteur
res_fact1immo
```

On peut également obtenir les saturations standardisées pour les deux modèles, ce qui sera intéressant dans une perspective de compréhension de la structure de la CFA, mais aussi de réutilisation dans des analyses complémentaires (régressions...).

```{r, echo = TRUE}
## Saturations standardisées
resid(fact_1immo,type="standardized")

resid(fact_2immo,type="standardized")

```

**Etape 4 : Représenter les deux modèles :**

Voici donc la représentation des équations structurelles, représentations qui obéit à un certain nombre de codes visuels  : les rectangles renvoient aux variables observées, les ellipses aux variables latentes, les doubles flèches associées aux rectangles et aux ellipses à l'erreur de chaque variable. Les couleurs vertes et rouges renvoient au signe de la corrélation et l'épaisseur à la force de la corrélation entre les variables et les facteurs.

```{r, echo = TRUE}

semPlot::semPaths(fact_1immo, "std",
             sizeMan = 8, sizeInt = 8, sizeLat = 8,
             edge.label.cex=0.8,
             fade=FALSE)

semPlot::semPaths(fact_2immo, "std",
             sizeMan = 8, sizeInt = 8, sizeLat = 8,
             edge.label.cex=0.8,
             fade=FALSE)
```

**Etape 5 : Comparer nos deux modèles**

Tout notre enjeu ici va être de comparer les deux modèles et de choisir celui qui s'ajuste le mieux à nos données. Pour ce faire nous pouvons comparer les deux modèles sur différents indices.

```{r, echo = TRUE}
# Pour comparer les modèles à l'aide des indices tel que l'AIC, le RMSEA, R2...
performance::compare_performance(fact_1immo, fact_2immo, verbose = FALSE)


# Une autre manière de visualiser très utile.
effectsize::interpret(fact_1immo)

effectsize::interpret(fact_2immo)

```

Dans les deux configurations testées, l'analyse factorielle confirmatoire présente un ajustement des modèles aux jeux de données "test" plutôt mauvais. Pour le deuxième modèle toutefois, 2 indices sont considérés comme satisfaisants et 3 indices ont des valeurs très proches des seuils (NFI : 0.8853; CFI : 0.8904 ; IFI : 0.8907). Ces indices indiquent l'écart entre un modèle nul (rien n'est lié) et un modèle saturé (tout est lié avec des coefficients à 1). Le fait que ces indices aient des valeurs de 0.88 ou 0.89 et non de 0.90 n'est pas particulièrement problématique. 

Concrètement, le deuxième modèle testé, avec 2 facteurs latents permettrait de mieux rendre compte de la complexité de nos données. Celui-ci s'ajustant le mieux à nos données.

<div class="alert alert-warning" role="alert">
La fonction `interpret()` donne des résultats pour 10 indices d'ajustement du modèle testé aux données de l'échantillon présenté. Toutefois, ces différents indices ont été proposé au fur et à mesure du développement des modèles en équations structurelles et, s'ils ne testent pas exactement la même chose, ils permettent de rendre compte de l'ajustement d'un modèle aux données présentées. Il n'est pas nécessaire que l'ensemble des indices présentés soient satisfaisant pour envisager un bon ajustement. Dans la littérature, certains indices sont sélectionnés et tous ne sont pas présentés. De plus, une utilisation trop contrainte des seuils augmente la probabilité de faux négatifs, c'est-à-dire de considérer qu'un modèle ne s'ajusterait pas aux données alors que si (Hooper et al., 2008). Prenons l'exemple d'un indice très cité et présenté dans la littérature tel que le CFI **Comparative Fit Indice**. Que fait-il exactement ? Il compare le modèle d’intérêt avec un modèle restreint qui sert de base. Itération de modèles entre le pire (modèle nul – à 0) et le parfait (voir modèle saturé - 1) et le CFI indique où se situe le modèle d’intérêt (le notre) sur ce continuum. Le seuil communément accepté de .95 indique une réduction de l’erreur, par rapport au modèle nul, de 95%. Le modèle nul étant un modèle où toutes les relations entre les variables sont rapportées à 0. Donc en gros notre modèle s’ajuste à nos données avec un risque de 5% que ce soit du au hasard. Quel que soit le contexte on est satisfait d’avoir une réduction de l’erreur de 95%. Donc plus le seuil est inférieur à .95, plus le risque que l’ajustement soit du au hasard augmente. (Van Laar, S., & Braeken, J., 2021).
</div>

Le package Lavaan, fait également quelques propositions pour améliorer notre modèle. Théoriquement, en tenant compte de toutes ces propositions, le modèle s'ajusterait parfaitment, mais on serait dans un cas évident de sur-ajustement aux données. En revanche, cela peut être intéressant d'en prendre connaissance afin de vérifier qu'aucune relation n'ait été oubliée et qui permettrait d'améliorer significativement le modèle. Cette relation doit bien évidemment faire sens théoriquement. La syntaxe utilisée est celle du package lavaan, on peut en trouver une traduction [ici](https://lavaan.ugent.be/tutorial/syntax1.html)

```{r, echo = TRUE}
modindices(fact_1immo) %>% arrange(-mi) %>% head(20)

modindices(fact_2immo) %>% arrange(-mi) %>% head(20)

```


## 2ème exemple : étudier la variation dans le temps d'un modèle

Un usage pertinent du couple AFE/AFC peut être d'étudier la permanence d'un phénomène. Ainsi, on peut utiliser l'AFE dans un premier temps pour faire émerger un modèle et vérifier dans un second temps avec l'analyse factorielle confirmatoire si le modèle est resté le même.

Dans cet article, nous venons de mettre en pratique le couple AFE/AFC dans le cadre d'une première approche afin de sélectionner le meilleur modèle factoriel. Voyons à présent si un modèle produit à l'aide d'une AFE, sur des données de 2011, se confirme sur des données de 2023. Ceci nous permettra de mettre en évidence ou non la permanence des phénomènes en présence. 

Nous utiliserons des données issue de l'INED dans un premier temps sur le cru 2011

- PAYS : Les différents pays du monde
- Superf : Superficie des différents pays en km²
- Pop : Nombre d'habitants en 2011
- tx_natalite : Le taux de natalité est le rapport du nombre de naissances vivantes de l'année à la population totale moyenne de l'année
- tx_mortalite : Le taux de mortalité est le rapport du nombre de décès de l'année à la population totale moyenne de l'année
- pop2050 : Projection du nombre d'habitants en 2050
- tx_mort_infantile : Nombre de décès d'enfants de moins d'un an rapporté au nombre de naissances vivantes
- indice_fecond : Le nombre d'enfants nés vivants des femmes d'un âge donné (ou d'une tranche d'âge) au cours de l'année, rapporté à la population moyenne de l'année des femmes de même âge (ou de la même classe d'âge) indique le taux de fécondité. L'indice de fécondité est la somme des taux de fécondité par âge d'une année.
- moins15 : Le nombre d'habitants de moins de 15 ans
- plus65 : Le nombre d'habitants de plus de 65 ans
- espvie_homme : Age moyen de décès atteint par les hommes en 2011
- espvie_femme : Age moyen de décès atteint par les femmes en 2011
- RNB_hab : Revenu National Brut rapporté au nombre d'habitants

### Préparation des données

```{r, echo = TRUE}

library(here)
csv_path <- here("data", "pop_societe_2011.csv")

pop2011 <- read.csv2(csv_path, row.names=1)

### Centrer et réduire les variables
dfz_2011 <-  data.frame(scale(pop2011, center=T, scale=T))
```

Nous ne présenterons pas les statistiques descriptives dans cet exemple afin de ne pas allourdir la lecture de cet article, toutefois, elles ont bien été vérifiées par les auteurs. 

Vérification des outliers et de la multicolinéarité : Nous faisons le choix ici d'être plus stricte concernant les outliers et les variables multicolinéaires. Cela comme précédemment, doit être assumé et justifié lors de l'analyse.

### Nettoyage des données

Etape 1 : les outliers

```{r, echo = TRUE}
# Multioutliers
#MCD avec le package rrcov
library(rrcov)
# 1- calcul de la distance MCD
mcd_result_2011 <- CovMcd(dfz_2011, alpha=0.75)

# 2- visualisation des outliers
plot(mcd_result_2011, which="all")

# suppression des valeurs manquantes
dfz_2011out<-cbind(dfz_2011, mcd_result_2011$wt)
dfz_2011outp<-subset(dfz_2011out, mcd_result_2011$wt %in% c(0,1))

# fusion de la base initiale et des distances de mahalanobis robustes
dfz_2011mah<-cbind(dfz_2011outp, mcd_result_2011$raw.mah)

# 3- suppression des outliers
dfz_2011p<-subset(dfz_2011mah, dfz_2011mah$`mcd_result_2011$raw.mah`< 100)

# On recalcule la distance de mahalanobis robuste sur notre base de données sans les premiers outliers, pour voir s'il en reste
dfz_2011_B<-subset(dfz_2011p, select = -c(`mcd_result_2011$raw.mah`, `mcd_result_2011$wt`))
# 1- calcul de la distance MCD
mcd_result_2011_2 <- CovMcd(dfz_2011_B, alpha=0.75)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
plot(mcd_result_2011_2, which="all")

```

15 outliers ont été supprimé avec le calcul de la distance de mahalanobis robuste. La suppression des outliers a été réalisée suite au calcul de la distance de mahalanobis robuste où le seuil de 100 comprend les valeurs les plus éloignées. L'objectif est de sortir de l'analyse les individus statistiques les plus porteurs de biais, néanmoins pour conserver du sens dans notre base de données nous ne supprimons pas tous les outliers relevé par la fonction, d'où le choix du seuil de 100. Ce seuil a été déterminé suite à différentes itérations sur notre jeux de données. Il sera donc différent avec d'autres données.

A présent aucune observation ne semble se détacher fortement des autres. Notre base de données compte maintenant 158 pays (sans la Chine, l'Inde, les Etats-Unis, le Canada, l'Australie, la Russie et bien d'autres...). 

Etape 2 : la multicolinéarité

```{r, echo = TRUE}

# corrélations

cor <- correlation(dfz_2011_B, method = "spearman")

cor %>%
  summary(redundant = FALSE)

### Etude du VIF

vifstep(dfz_2011_B, method = "spearman")

dfz2011_multi <- dfz_2011_B %>% select(-tx_natalite, -espvie_homme, -pop2050, -moins15, -tx_mortalite, -espvie_femme )
vifstep(dfz2011_multi, method = "spearman")

# Après suppression des variables colinéaires, notre jeu de données en compte 6.
```

### Réaliser l'AFE sur les données 2011

Etape 1 : Déterminer le nombre de facteurs

```{r, echo = TRUE}

# Regardons à présent en combien de facteurs latents se structurent nos variables
n <- n_factors(dfz2011_multi)
n

library(see)
plot(n) + theme_modern()

# Les méthodes suggèrent 2 facteurs
```

Etape 2 : Vérifier le KMO et la sphéracité

```{r, echo = TRUE}

performance::check_factorstructure(dfz2011_multi)

# Nos données sont factorisables
```

Etape 3 : Réaliser l'AFE

```{r, echo = TRUE}

# efa
efa_2011 <- lavaan::efa(dfz2011_multi, nfactors = 2, rotation="promax", estimator="MLR")
efa_2011

```

Nous avons donc deux facteurs latents. Un premier qui corrèle positivement avec la surface et la population, et un deuxième facteur latent qui oppose d'un côté score élevé  sur la mortalité infantile et indice de fécondité avec de l'autre la proportion d'habitant de plus de 65 ans et et le revenu national brut par habitant.

### 2ème temps L'analyse factorielle confirmatoire

Testons si la structure factorielle obtenue grâce à l'AFE se retrouve sur les données de 2023. Si c'est le cas cela implique une permanence en 2023 du phénomène étudié en 2011.

Etape 1 : Chargement et préparation des données

```{r, echo = TRUE}
# Charger les données

library(here)
csv_path <- here("data", "data_monde_afe_02.csv")

pop2023 <- read.csv2(csv_path, row.names=1)

pop2023p<-subset(pop2023, select = c(Superf, Pop, tx_mort_infantile, indice_fecond, RNB_hab, plus65))

### Centrer et réduire les variables
dfz_2023 <-  data.frame(scale(pop2023p, center=T, scale=T))


# Multioutliers
# MCD avec le package rrcov
library(rrcov)
# 1- calcul de la distance MCD
mcd_result_2023 <- CovMcd(dfz_2023, alpha=0.75)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
plot(mcd_result_2023, which="all")

# suppression des valeurs manquantes
dfz_2023out<-cbind(dfz_2023, mcd_result_2023$wt)
dfz_2023outp<-subset(dfz_2023out, mcd_result_2023$wt %in% c(0,1))

# fusion de la base initiale et des distances de mahalanobis robustes
dfz_2023mah<-cbind(dfz_2023outp, mcd_result_2023$raw.mah)

# 3- suppression des outliers
dfz_2023p<-subset(dfz_2023mah, dfz_2023mah$`mcd_result_2023$raw.mah`< 100)

# On recalcule la distance de mahalanobis robuste sur notre base de données sans les premiers outliers, pour voir s'il en reste
dfz_2023_B<-subset(dfz_2023p, select = -c(`mcd_result_2023$raw.mah`, `mcd_result_2023$wt`))
# 1- calcul de la distance MCD
mcd_result_2023_2 <- CovMcd(dfz_2023_B, alpha=0.75)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
plot(mcd_result_2023_2, which="all")

# 14 outliers ont été supprimé avec le calcul de la distance de mahalanobis robuste. A présent aucune observation semble se détacher fortement des autres. Notre base de données compte maintenant 158 pays (sans la Chine, l'Inde, les Etats-Unis, le Canada, l'Australie, la Russie et bien d'autres...)
```
Globalement on retrouve les même outliers principaux (Chine, Russie, Inde, Canada, Etats-Unis) avec malgré tout quelques variations.
Pour étudier la permanence dans le temps de notre phénomène nous avons donc gardé les même variables qu'en 2011 pour permettre une comparaison entre ces deux années.

Etape 2 : Réaliser la CFA

```{r, echo = TRUE}
### Attacher car R refuse les $
attach(dfz_2023_B)

model23 <- 'F1 =~ Superf + Pop
           F2 =~ indice_fecond + plus65 + RNB_hab'

library(lavaan)

fit23 <- cfa(model23, std.lv=T, estimator="MLR", data=dfz_2023_B)


effectsize::interpret(fit23)


semPlot::semPaths(fit23, "std",
             sizeMan = 8, sizeInt = 8, sizeLat = 8,
             edge.label.cex=0.8,
             fade=FALSE)

```
Les indices de la CFA sont satisfaisants (6 sur 10, et 2 sont proches des seuils), ce qui traduit une bonne adéquation du modèle à nos données. La structure testée en 2011 sur certains pays se retrouve bien en 2023. La distinction entre les pays étudiés se structure selon 2 facteurs : la superficie et la population d'une part et l'indice de fécondité et la part des plus de 65 ans dans la population ainsi que le RNB. Il est à noter que ce deuxième facteur rassemble des indices contraires, c'est-à-dire que les pays ayant un fort taux de fécondité sont aussi ceux qui ont une part des plus de 65 ans dans leur population faible et un RNB bas. 

Si les résultats ne sont pas révolutionnaires et que le nettoyage préliminaire ne permet pas de leur attribuer une portée générale, nous avons toutefois pu observer que le duo analyse factorielle exploratoire et analyse factorielle confirmatoire permet de rendre compte de la stabilité d'une structure d'un modèle théorique dans le temps. 


## Est-ce que je mesure bien ce que je pense mesurer : l'exemple des tests psychométriques en Psychologie

En Psychologie, un exemple classique de l'utilisation des couples AFE/AFC concerne la validation des tests psychométriques.
Afin de réaliser des tests standardisés pour évaluer des processus psychologiques, les psychologues ont recours à ce couple d'analyses factorielles, en réalisant une analyse factorielle exploratoire sur un premier échantillon et une analyse factorielle confirmatoire sur un second échantillon (ayant tous 2 les mêmes caractéristiques).

Nous allons illustrer notre démarche avec l'utilisation d'un outil psychométrique le *Revised Paranormal Beliefs Scale - RPBS* à partir des données issues de l'article de Pennycook G, et al. 2020.

Le RPBS est un outil psychométrique utilisé afin de mesurer la croyance des individus dans des phénomènes paranormaux. Habituellement composé de 26 items répartis en 7 facteurs, la version utilisée dans l'article présenté se décompose en 22 variables répartis en 6 facteurs latents. Le facteur correspondant aux croyances religieuses traditionnelles ayant été sorti de l'outil, avec les variables qui le composent.

Les variables de notre base de données se répartissent comme ceci, un exemple d'intitulé de variable est présenté entre parenthèses pour chaque facteur : 

- Phénomènes parapsychologiques (*“Lire dans les pensées est possible”*) : PB_1, PB_7, PB_13, PB_19  
- Sorcellerie (*“Les sorciers existent”*) : PB_2, PB_8, PB_14, PB_20
- Superstition (*“Les chats noirs portent malheur”*) : PB_3, PB_9, PB_15
- Spiritualité (*“Il est possible de communiquer avec les morts”*) : PB_4, PB_10, PB_16, PB_21 
- Formes de vie extraordinaires (*“Le monstre du Loch Ness existe”*) : PB_5, PB_11, PB_17
- Précognition (*“L'astrologie est une voie pertinente pour prédire le futur”*) : PB_6, PB_12, PB_18, PB_22

### Préparation du jeu de données

Charger le jeu de données et standardiser les variables d'intérêt.

```{r, echo = TRUE}

# Chargement des données de base

library(here)
csv_path <- here("data", "Study3_RPB.csv")

RPB <- read.csv2(csv_path, row.names=1)

# Sélection des 22 items : 

RPBp<-subset(RPB, select = c("PB_1", "PB_2", "PB_3", "PB_4", "PB_5", "PB_6", "PB_7" ,"PB_8", "PB_9", "PB_10", "PB_11", "PB_12", "PB_13", "PB_14", "PB_15", "PB_16", "PB_17", "PB_18", "PB_19", "PB_20", "PB_21", "PB_22"))

# Conversion des variables en format numérique (car elles sont considérées comme catégorielles)
RPBpn <- as.data.frame(lapply(RPBp, as.numeric))

```

Nous allons débuter par partitionner notre jeu de données pour ne pas exécuter l'AFE et l'AFC sur le même échantillon. 

```{r}
## En premier lien le partitionnement des data
partitions <- datawizard::data_partition(RPBpn, proportion = 0.5, seed = 424)
training <- partitions$p_0.5
test <- partitions$test

training$.row_id <- NULL
test$.row_id <- NULL

### Centrer et réduire les variables de nos 2 jeux de données
trainingz <-  na.omit(data.frame(scale(training, center=T, scale=T)))
testz <-  na.omit(data.frame(scale(test, center=T, scale=T)))
```

Nous avons vérifié les statistiques descriptives sur notre jeu de données. Nous ne les présentons pas dans cet exemple pour plus de lisibilité. Il est toutefois à noter qu'il n'y a pas de différence statistiquement significative des scores obtenus sur chaque variable pour nos deux échantillons *training* et *test*.

### Nettoyage des données

**Etape 1 : les outliers**

Identification et suppression des outliers sur nos deux jeux de données test et training.

**Multioutliers base training**

```{r}
# Multioutliers base training
#MCD avec le package rrcov
library(rrcov)
# 1- calcul de la distance MCD
mcd_RPBS1 <- CovMcd(trainingz, alpha=0.75)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
#plot(mcd_RPBS1, which="all")

# suppression des valeurs manquantes
trainingzout<-cbind(trainingz, mcd_RPBS1$wt)
trainingzoutp<-subset(trainingzout, mcd_RPBS1$wt %in% c(0,1))

# fusion de la base initiale et des distances de mahalanobis robustes
trainingzmah<-cbind(trainingzoutp, mcd_RPBS1$raw.mah)

# 3- suppression des outliers
trainingzp<-subset(trainingzmah, trainingzmah$`mcd_RPBS1$raw.mah`< 100)

# On recalcule la distance de mahalanobis robuste sur notre base de données sans les premiers outliers, pour voir s'il en reste
trainingz_B<-subset(trainingzp, select = -c(`mcd_RPBS1$raw.mah`, `mcd_RPBS1$wt`))
# 1- calcul de la distance MCD
mcd_RPBS1_2 <- CovMcd(trainingz_B, alpha=0.75)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
#plot(mcd_RPBS1_2, which="all")
```


**Multioutliers base test**

```{r}
# Multioutliers base test
#MCD avec le package rrcov

# 1- calcul de la distance MCD
mcd_RPBS2 <- CovMcd(testz, alpha=0.75)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
#plot(mcd_RPBS2, which="all")

# suppression des valeurs manquantes
testzout<-cbind(testz, mcd_RPBS2$wt)
testzoutp<-subset(testzout, mcd_RPBS2$wt %in% c(0,1))

# fusion de la base initiale et des distances de mahalanobis robustes
testzmah<-cbind(testzoutp, mcd_RPBS2$raw.mah)

# 3- suppression des outliers
testzp<-subset(testzmah, testzmah$`mcd_RPBS2$raw.mah`< 100)

# On recalcule la distance de mahalanobis robuste sur notre base de données sans les premiers outliers, pour voir s'il en reste
testz_B<-subset(testzp, select = -c(`mcd_RPBS2$raw.mah`, `mcd_RPBS2$wt`))
# 1- calcul de la distance MCD
mcd_RPBS2_2 <- CovMcd(testz_B, alpha=0.75)
# L'objet `mcd_result` contient toutes les informations concernant le calcul sur notre base de données
# 2- visualisation des outliers
#plot(mcd_RPBS2_2, which="all")

# Aucun sujet ne se détache du groupe avec le calcul de la distance de Mahalanobis robuste dans chacune des 2 bases de données testées après les premières suppression. Nous ne supprimons pas de valeurs supplémentaires.

```

Notre jeu de données **training** comportait 6 outliers et le jeu de données **test** en comportait 10. Nous les avons donc supprimés. Tout comme l'exemple précédent, les outliers entrainant le plus de biais ont été supprimés de notre jeu de données. Le seuil de 100 a également été retenu suite à différentes itérations du calcul de la distance de Mahalanobis robuste. 

**Etape 2 : la multicolinéarité**

```{r}
# corrélations

cor <- correlation(trainingz_B, method = "spearman")

cor %>%
  summary(redundant = FALSE)

cor <- correlation(testz_B, method = "spearman")

cor %>%
  summary(redundant = FALSE)


### gestion multicolinéarité

vifstep(trainingz_B, method = "spearman")

vifstep(testz_B, method = "spearman")

```


Aucun problème de multicolinéarité n'a été détecté, tous nos VIF sont inférieurs à 5 pour nos 2 jeux de données.

Nous allons pouvoir procéder aux étapes suivantes.

### Réalisons l'AFE

Nos données sont-elles factorisables ? - KMO & Bartlett
```{r}
#Avec psych
## KMO
KMO(trainingz_B)
## Test de sphéricité
cortest.bartlett(trainingz_B, n=370)


# Avec performance
performance::check_factorstructure(trainingz_B)
```

Les indices de sphéricité et de KMO (merveilleux) indiquent que nos données sont factorisables.

Procédons à l'AFE

```{r}

# Nombre de facteurs à conserver
n <- n_factors(trainingz_B)
n

library(see)
plot(n) + theme_modern()

#SCREE_PLOT(trainingz_B, corkind="spearman", verbose=T)

AFERP<-lavaan::efa(trainingz_B, nfactors = 4, estimator = "MLR")
AFERP

```

Une structure en 4 facteurs est proposée avec l'analyse factorielle exploratoire que nous venons de réaliser, et donc non en 6 comme présenté dans l'article. Les *estimate* ont des valeurs comprises entre 0.37 et 0.99 ce qui témoigne de liens assez forts avec la variable latente.

### Calcul de l'analyse factorielle confirmatoire sur la base test

Vérifions si cette structure en 4 facteurs se retrouve sur notre second jeu de données.

**1 - Procédons à l'analyse factorielle confirmatoire**

```{r}
library(lavaan)

attach(testz_B)

model <- 'F1 =~ PB_1 + PB_5 + PB_7 + PB_11 + PB_13 + PB_19
          F2 =~ PB_3 + PB_9 + PB_12 + PB_15
          F3 =~ PB_2 + PB_8 + PB_14 + PB_20
          F4 =~ PB_4 + PB_6 + PB_10 + PB_16 + PB_17 + PB_18 + PB_21 + PB_22'

fit2 <- cfa (model, std.lv=T, estimator="MLR", data=testz_B)

```


**2- Vérification de l'ajustement du modèle à nos données**
```{r}
## Résultat des indices

effectsize::interpret(fit2)
```

D'après un panel d'indices le modèle en 4 facteurs s'ajuste de façon satisfaisante aux données (PNFI & SRMR) et de façon tendancielle pour le NFI (0.869), le NNFI (0.884), le CFI (0.885) et l'IFI (0.885). 

**3- Extraction des coefficients standardisés**

```{r}

## Saturations standardisées

# resid(fit2,type="standardized")
```

Les coefficients traduisant le lien entre chaque variable et la variable latente associée (les facteurs) sont plutôt élevés (entre 0.56 et 0.86) ce qui traduit des liens assez forts entre nos variables observées et nos variables latentes. 

**4- Observation graphique de la structure obtenue**
```{r}

# On peut également représenter ce modèle :

semPlot::semPaths(fit2, "std",
             sizeMan = 8, sizeInt = 8, sizeLat = 8,
             edge.label.cex=0.8,
             fade=FALSE)
```

La structure décrite dans l'article de Pennycook et al. 2020 n'est pas retrouvée sur les données testées. Toutefois, une autre structure se dégage et est stable sur nos deux échantillons, comme en témoignent les résultats de nos analyses factorielles exploratoires et confirmatoires. 

L'article décrit une échelle en 22 items répartis en 6 catégories de croyances aux phénomènes paranormaux, mais nous retrouvons une structure en 4 facteurs avec les mêmes items sur les mêmes données. Ceci peut être du a plusieurs éléments. Nous n'avons pas d'indication sur le traitement des valeurs extrêmes de la part des auteurs de l'article. De plus, nous n'avons pas d'éléments nous permettant d'affirmer qu'ils ont effectivement partitionné leur jeu de données avant de procéder à leurs analyses factorielles. 

<div class="alert alert-danger" role="warning">
Un autre point à souligner, et pas des moindres, les auteurs n'ont très certainement pas réalisé d'analyse factorielle exploratoire. En effet, à partir du moment où un test psychométrique est validé, c'est-à-dire qu'il a déjà été éprouvé par le couple AFE/AFC sur un jeu de données assez conséquent, avec une population ayant les mêmes caractéristiques, il n'est pas nécessaire de remettre en cause la structure du test et nous pouvons directement procéder à une analyse factorielle confirmatoire, afin de vérifier si le modèle alors pré-établi par d'autres s'ajuste à nos données. Ceci est conseillé afin de ne pas multiplier les tests statistiques et entraîner une inflation des résultats faussements positifs (encore appelés erreur de type II).
</div>

La structure obtenue en 4 facteurs reste cohérente avec la proposition de départ en 6 facteurs. Certains regroupements restent inchangés, d'autres voient quelques modifications (2 items sont majoritairement reliés à un autre facteur latent que celui proposé dans la structure initiale), mais la structure obtenue a du sens et peut tout-à-fait servir de base de discussion à la construction d'outils psychométriques sur le sujet.
Pour information, avec notre nouvelle structure nous obtenons la répartition suivante (en anglais) : 

- F1 (Phénomènes parapsychologiques / Fomres de vie extraordinaires): 
  1\. Some individuals are able to levitate (lift) objects through mental forces. ; 
  5\. The abominable snowman of Tibet exists. ; 
  7\. Psychokinesis, the movement of objects through psychic powers, does exist. ; 
  11\. The Loch Ness monster of Scotland exists. ; 
  13\. A person's thoughts can influence the movement of a physical object. ; 
  19\. Mind reading is not possible
- F2 (Superstition + item 12 (qui était dans la structure initiale relié majoritairement au facteur "Précognition")) :
  3\. Black cats can bring bad luck. ; 
  9\. If you break a mirror, you will have bad luck. ; 
  12\. The horoscope accurately tells a person's future. ;  
  15\. The number "13" is unlucky.
- F3 (Sorcellerie): 
  2\. Black magic really exists. ; 
  8\. Witches do exist. ; 
  14\. Through the use of formulas and incantations, it is possible to cast spells on persons. ; 
  20\. There are actual cases of witchcraft.
- F4 (Spiritualité / Précognition - item12 + item17 (qui était dans la struture initiale majoritairement relié au facteur latent "Formes de vies extraordinaires")): 
  4\. Your mind or soul can leave your body and travel (astral projection). ; 
  6\. Astrology is a way to accurately predict the future.; 
  10\. During altered states, such as sleep or trances, the spirit can leave the body.;   
  16\. Reincarnation does occur. ; 
  17\. There is life on other planets. ; 
  18\. Some psychics can accurately predict the future.; 
  21\. It is possible to communicate with the dead. ; 
  22\. Some people have an unexplained ability to predict the future.

# Conclusion {-}
Nous avons ainsi présenté pas à pas trois exemples différents d'utilisation de l'AFE et en suivant de la CFA. L'idée était de présenter une méthode ancienne mais peu utilisée en dehors de la Psychologie. Il ne s'agit pas de remplacer l'ACP mais de proposer une alternative, et surtout de proposer aux usagers de faire un choix conscient sur la méthode plutôt que de répondre à une habitude disciplinaire.

Ainsi, si vous souhaitez explorer vos données et identifier des facteurs latents corrélés (ou non) afin de faire émerger une structure synthétique, voir si la structure observée est cohérente avec un modèle théorique, ou encore si cette structure observée est stable dans le temps, alors l'utilisation du couple entre AFE/CFA est tout-à-fait pertinente.

# Bibliographie {-}

<div id="refs">

- Bartlett, M.S. (1937) Properties of Sufficiency and Statistical Test. Proceedings of the Royal Society A, 160, 268-282. [https://doi.org/10.1098/rspa.1937.0109](https://doi.org/10.1098/rspa.1937.0109)

- Benzecri J.-P. (1973), L’analyse des données, Paris, Dunod, vol. 2 : Correspondances

- Farrar, D. E., & Glauber, R. R. (1967). Multicollinearity in Regression Analysis: The Problem Revisited. The Review of Economics and Statistics, 49(1), 92–107. [https://doi.org/10.2307/1937887](https://doi.org/10.2307/1937887).

- Flora, D. B., & Flake, J. K. (2017), The purpose and practice of exploratory and confirmatory factor analysis in psychological research: Decisions for scale development and validation. Canadian Journal of Behavioural Science / Revue canadienne des sciences du comportement, 49(2), 78–88. [https://doi.org/10.1037/cbs0000069](https://doi.org/10.1037/cbs0000069)

- Gnanadesikan, R., & Kettenring, J. R. (1972), Robust Estimates, Residuals, and Outlier Detection with Multiresponse Data. Biometrics, 28(1), 81–124. [https://doi.org/10.2307/2528963](https://doi.org/10.2307/2528963)

- Hooper, D., Coughlan, J., & Mullen, M. R. (2008), Structural Equation Modelling: Guidelines for Determining Model Fit. The Electronic Journal of Business Research Methods, 6, 53-60.
- Kaiser, H.F. (1974) An index of factorial simplicity. Psychometrika 39, 31–36. [https://doi.org/10.1007/BF02291575](https://doi.org/10.1007/BF02291575)

- Kyriazos, T. and Poga, M. (2023) Dealing with Multicollinearity in Factor Analysis: The Problem, Detections, and Solutions. Open Journal of Statistics, 13, 404-424. doi: [10.4236/ojs.2023.133020](https://doi.org/10.4236/ojs.2023.133020)

- Kyriazos, T. and Poga-Kyriazou, M. (2023) Applied Psychometrics: Estimator Considerations in Commonly Encountered Conditions in CFA, SEM, and EFA Practice. Psychology, 14, 799-828. doi: [https://doi.org/10.4236/psych.2023.145043](https://doi.org/10.4236/psych.2023.145043)

- Leys, C., Klein, O., Dominicy, Y., and Ley., C., 2018, “Detecting Multivariate Outliers: Use a Robust Variant of the Mahalanobis Distance.” Journal of Experimental Social Psychology 74: 150–56. [https://doi.org/10.1016/j.jesp.2017.09.011](https://doi.org/10.1016/j.jesp.2017.09.011)

- Mahalanobis, P., C., 1936, « On the generalised distance in statistics », Proceedings of the National Institute of Sciences of India, vol. 2, no 1,‎ 1936, p. 49–55

- Makowski, (2018). The psycho Package: an Efficient and Publishing-Oriented Workflow for Psychological Science. Journal of Open Source Software, 3(22), 470. [https://doi.org/10.21105/joss.00470](https://doi.org/10.21105/joss.00470)

- Pages, J-P., et al., (1979), Analyse factorielle : Un peu d'histoire et de géométrie, Revue de statistiques appliquée, tome 27, n°1, p.5-28.

- Pearson F.R.S., K. (1901) LIII. On lines and planes of closest fit to systems of points in space, The London, Edinburgh, and Dublin Philosophical Magazine and Journal of Science, 2:11, 559-572, DOI: [10.1080/14786440109462720](https://doi.org/10.1080/14786440109462720)

- Pennycook G, Cheyne JA, Koehler DJ, Fugelsang JA, 2020, On the belief that beliefs should change according to evidence: Implications for conspiratorial, moral, paranormal, political, religious, and science beliefs. Judgment and Decision Making. 2020;15(4):476-498. doi:[10.1017/S1930297500007439](https://doi.org/10.1017/S1930297500007439)

- Spearman, C. (1904). The Proof and Measurement of Association between Two Things. The American Journal of Psychology, 15(1), 72–101. [https://doi.org/10.2307/1412159](https://doi.org/10.2307/1412159)

- Tabachnick, B., & Fidell, L., (2014), Using Multivariate Statistics (6th ed.). Harlow: Pearson Education

- Van Laar, S., & Braeken, J., 2021, Understanding the Comparative Fit Index : It’s All About Base !, Practical Assessment, Reasearch & Evaluation, Vol 26, N°26

- Yong, A. G., & Pearce, S. (2013) A Beginner’s Guide to Factor Analysis: Focusing on Exploratory Factor Analysis, Tutorials in Quantitative Methods for Psychology, 9(2), 79-94. doi: [10.20982/tqmp.09.2.p079](https://doi.org/10.20982/tqmp.09.2.p079)

- Zijlstra, W. P., van der Ark, L. A., & Sijtsma, K. (2011). Outliers in Questionnaire
Data: Can They Be Detected and Should They Be Removed? Journal of Educational and Behavioral Statistics, 36(2), 186–212. [http://www.jstor.org/stable/29789477](http://www.jstor.org/stable/29789477)

</div>

# Annexes {-}

## Info session  {-}

```{r session_info, echo=FALSE}
kableExtra::kable_styling(knitr::kable(rzine::sessionRzine()[[1]], row.names = F))
kableExtra::kable_styling(knitr::kable(rzine::sessionRzine()[[2]], row.names = F))
```

## Citation {-}

```{r Citation, echo=FALSE}
rref <- bibentry(
   bibtype = "misc",
   title = "Titre de la fiche",
   subtitle = "Sous-Titre de la fiche",
   author = c("Premier Auteur.e", "Second Auteur.e"),
   doi = "10.48645/xxxxxx",
   url = "https://rzine.fr/publication_rzine/xxxxxxx/",
   keywords ="FOS: Other social sciences",
   language = "fr",
   publisher = "FR2007 CIST",
   year = 2021,
   copyright = "Creative Commons Attribution Share Alike 4.0 International")

``` 

`r capture.output(print(rref))`

### BibTex : {-}

```{r generateBibTex, echo=FALSE}

writeLines(toBibtex(rref), "cite.bib")
toBibtex(rref)

``` 

<br/>

## Glossaire {- #endnotes}

```{js, echo=FALSE}

$(document).ready(function() {
  $('.footnotes ol').appendTo('#endnotes');
  $('.footnotes').remove();
});

```
